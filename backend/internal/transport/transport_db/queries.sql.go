// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package transport_db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createTrip = `-- name: CreateTrip :one

INSERT INTO giki_transport.trip(route_id, departure_time, booking_opens_at, booking_closes_at, total_capacity, available_seats, base_price, status)
VALUES ($1, $2, $3, $4, $5, $6, $7, 'SCHEDULED')
RETURNING id
`

type CreateTripParams struct {
	RouteID         uuid.UUID      `json:"route_id"`
	DepartureTime   time.Time      `json:"departure_time"`
	BookingOpensAt  time.Time      `json:"booking_opens_at"`
	BookingClosesAt time.Time      `json:"booking_closes_at"`
	TotalCapacity   int32          `json:"total_capacity"`
	AvailableSeats  int32          `json:"available_seats"`
	BasePrice       pgtype.Numeric `json:"base_price"`
}

func (q *Queries) CreateTrip(ctx context.Context, arg CreateTripParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createTrip,
		arg.RouteID,
		arg.DepartureTime,
		arg.BookingOpensAt,
		arg.BookingClosesAt,
		arg.TotalCapacity,
		arg.AvailableSeats,
		arg.BasePrice,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createTripStop = `-- name: CreateTripStop :exec
INSERT INTO giki_transport.trip_stops (trip_id, stop_id, sequence_order)
VALUES ($1, $2, $3)
`

type CreateTripStopParams struct {
	TripID        uuid.UUID `json:"trip_id"`
	StopID        uuid.UUID `json:"stop_id"`
	SequenceOrder int32     `json:"sequence_order"`
}

func (q *Queries) CreateTripStop(ctx context.Context, arg CreateTripStopParams) error {
	_, err := q.db.Exec(ctx, createTripStop, arg.TripID, arg.StopID, arg.SequenceOrder)
	return err
}

const getAllRoutes = `-- name: GetAllRoutes :many

SELECT id, name FROM giki_transport.routes WHERE is_active = TRUE ORDER BY name ASC
`

type GetAllRoutesRow struct {
	ID   uuid.UUID `json:"id"`
	Name string    `json:"name"`
}

func (q *Queries) GetAllRoutes(ctx context.Context) ([]GetAllRoutesRow, error) {
	rows, err := q.db.Query(ctx, getAllRoutes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllRoutesRow
	for rows.Next() {
		var i GetAllRoutesRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRouteStopsDetails = `-- name: GetRouteStopsDetails :many

SELECT
    -- route details
    r.id as route_id, r.name as route_name,
    r.default_booking_open_offset_hours,
    r.default_booking_close_offset_hours,
    -- stops details
    s.id as stop_id, s.address as stop_name,
    -- route specific stops sequence
    rms.default_sequence_order,
    rms.is_default_active

FROM giki_transport.routes as r
JOIN giki_transport.route_master_stops as rms ON r.id = rms.route_id
JOIN giki_transport.stops as s ON rms.stop_id = s.id

WHERE r.id = $1

ORDER BY rms.default_sequence_order ASC
`

type GetRouteStopsDetailsRow struct {
	RouteID                        uuid.UUID   `json:"route_id"`
	RouteName                      string      `json:"route_name"`
	DefaultBookingOpenOffsetHours  pgtype.Int4 `json:"default_booking_open_offset_hours"`
	DefaultBookingCloseOffsetHours pgtype.Int4 `json:"default_booking_close_offset_hours"`
	StopID                         uuid.UUID   `json:"stop_id"`
	StopName                       string      `json:"stop_name"`
	DefaultSequenceOrder           int32       `json:"default_sequence_order"`
	IsDefaultActive                bool        `json:"is_default_active"`
}

func (q *Queries) GetRouteStopsDetails(ctx context.Context, id uuid.UUID) ([]GetRouteStopsDetailsRow, error) {
	rows, err := q.db.Query(ctx, getRouteStopsDetails, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRouteStopsDetailsRow
	for rows.Next() {
		var i GetRouteStopsDetailsRow
		if err := rows.Scan(
			&i.RouteID,
			&i.RouteName,
			&i.DefaultBookingOpenOffsetHours,
			&i.DefaultBookingCloseOffsetHours,
			&i.StopID,
			&i.StopName,
			&i.DefaultSequenceOrder,
			&i.IsDefaultActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRouteWeeklySchedule = `-- name: GetRouteWeeklySchedule :many

SELECT id, day_of_week, departure_time
FROM giki_transport.route_weekly_schedules
WHERE route_id = $1
ORDER BY day_of_week, departure_time
`

type GetRouteWeeklyScheduleRow struct {
	ID            uuid.UUID   `json:"id"`
	DayOfWeek     int32       `json:"day_of_week"`
	DepartureTime pgtype.Time `json:"departure_time"`
}

func (q *Queries) GetRouteWeeklySchedule(ctx context.Context, routeID uuid.UUID) ([]GetRouteWeeklyScheduleRow, error) {
	rows, err := q.db.Query(ctx, getRouteWeeklySchedule, routeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRouteWeeklyScheduleRow
	for rows.Next() {
		var i GetRouteWeeklyScheduleRow
		if err := rows.Scan(&i.ID, &i.DayOfWeek, &i.DepartureTime); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUpcomingTripsByRoute = `-- name: GetUpcomingTripsByRoute :many
SELECT
    t.id as trip_id,
    t.departure_time,
    t.booking_opens_at,
    t.booking_closes_at,
    t.total_capacity,
    t.available_seats,
    t.base_price,
    t.status,          -- e.g. 'SCHEDULED', 'CANCELLED'
    t.booking_status,  -- e.g. 'OPEN', 'CLOSED'

    d.name as driver_name,

    -- Stop Details for this specific trip
    ts.stop_id,
    s.address as stop_name,
    ts.sequence_order

FROM giki_transport.trip t
         JOIN giki_transport.driver d ON t.driver_id = d.id
         JOIN giki_transport.trip_stops ts ON t.id = ts.trip_id
         JOIN giki_transport.stops s ON ts.stop_id = s.id

WHERE t.route_id = $1
  AND t.departure_time > NOW() -- Only future trips
  AND t.status != 'COMPLETED'  -- Hide finished trips

ORDER BY t.departure_time ASC, ts.sequence_order ASC
`

type GetUpcomingTripsByRouteRow struct {
	TripID          uuid.UUID      `json:"trip_id"`
	DepartureTime   time.Time      `json:"departure_time"`
	BookingOpensAt  time.Time      `json:"booking_opens_at"`
	BookingClosesAt time.Time      `json:"booking_closes_at"`
	TotalCapacity   int32          `json:"total_capacity"`
	AvailableSeats  int32          `json:"available_seats"`
	BasePrice       pgtype.Numeric `json:"base_price"`
	Status          pgtype.Text    `json:"status"`
	BookingStatus   string         `json:"booking_status"`
	DriverName      string         `json:"driver_name"`
	StopID          uuid.UUID      `json:"stop_id"`
	StopName        string         `json:"stop_name"`
	SequenceOrder   int32          `json:"sequence_order"`
}

func (q *Queries) GetUpcomingTripsByRoute(ctx context.Context, routeID uuid.UUID) ([]GetUpcomingTripsByRouteRow, error) {
	rows, err := q.db.Query(ctx, getUpcomingTripsByRoute, routeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUpcomingTripsByRouteRow
	for rows.Next() {
		var i GetUpcomingTripsByRouteRow
		if err := rows.Scan(
			&i.TripID,
			&i.DepartureTime,
			&i.BookingOpensAt,
			&i.BookingClosesAt,
			&i.TotalCapacity,
			&i.AvailableSeats,
			&i.BasePrice,
			&i.Status,
			&i.BookingStatus,
			&i.DriverName,
			&i.StopID,
			&i.StopName,
			&i.SequenceOrder,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
