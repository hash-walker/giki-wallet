// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package payment_db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const clearPollingStatus = `-- name: ClearPollingStatus :exec
UPDATE giki_wallet.gateway_transactions
SET is_polling = FALSE
WHERE txn_ref_no = $1
`

func (q *Queries) ClearPollingStatus(ctx context.Context, txnRefNo string) error {
	_, err := q.db.Exec(ctx, clearPollingStatus, txnRefNo)
	return err
}

const createAuditLog = `-- name: CreateAuditLog :one

INSERT INTO giki_wallet.payment_audit_log (
    event_type, raw_payload, txn_ref_no, gateway_ref, user_id
) VALUES ($1, $2, $3, $4, $5)
RETURNING id, event_type, raw_payload, txn_ref_no, gateway_ref, user_id, processed, processed_at, process_error, retry_count, received_at
`

type CreateAuditLogParams struct {
	EventType  GikiWalletAuditEventType `json:"event_type"`
	RawPayload []byte                   `json:"raw_payload"`
	TxnRefNo   pgtype.Text              `json:"txn_ref_no"`
	GatewayRef pgtype.Text              `json:"gateway_ref"`
	UserID     pgtype.UUID              `json:"user_id"`
}

// =============================================================================
// AUDIT LOG QUERIES
// =============================================================================
func (q *Queries) CreateAuditLog(ctx context.Context, arg CreateAuditLogParams) (GikiWalletPaymentAuditLog, error) {
	row := q.db.QueryRow(ctx, createAuditLog,
		arg.EventType,
		arg.RawPayload,
		arg.TxnRefNo,
		arg.GatewayRef,
		arg.UserID,
	)
	var i GikiWalletPaymentAuditLog
	err := row.Scan(
		&i.ID,
		&i.EventType,
		&i.RawPayload,
		&i.TxnRefNo,
		&i.GatewayRef,
		&i.UserID,
		&i.Processed,
		&i.ProcessedAt,
		&i.ProcessError,
		&i.RetryCount,
		&i.ReceivedAt,
	)
	return i, err
}

const createGatewayTransaction = `-- name: CreateGatewayTransaction :one
INSERT INTO giki_wallet.gateway_transactions(user_id, idempotency_key, bill_ref_id, txn_ref_no, payment_method, status, amount)
VALUES ($1, $2,$3,$4, $5, $6, $7)
RETURNING id, user_id, idempotency_key, bill_ref_id, txn_ref_no, payment_method, gateway_rrn, status, amount, raw_response, is_polling, created_at, updated_at
`

type CreateGatewayTransactionParams struct {
	UserID         uuid.UUID     `json:"user_id"`
	IdempotencyKey uuid.UUID     `json:"idempotency_key"`
	BillRefID      string        `json:"bill_ref_id"`
	TxnRefNo       string        `json:"txn_ref_no"`
	PaymentMethod  string        `json:"payment_method"`
	Status         CurrentStatus `json:"status"`
	Amount         int64         `json:"amount"`
}

func (q *Queries) CreateGatewayTransaction(ctx context.Context, arg CreateGatewayTransactionParams) (GikiWalletGatewayTransaction, error) {
	row := q.db.QueryRow(ctx, createGatewayTransaction,
		arg.UserID,
		arg.IdempotencyKey,
		arg.BillRefID,
		arg.TxnRefNo,
		arg.PaymentMethod,
		arg.Status,
		arg.Amount,
	)
	var i GikiWalletGatewayTransaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.IdempotencyKey,
		&i.BillRefID,
		&i.TxnRefNo,
		&i.PaymentMethod,
		&i.GatewayRrn,
		&i.Status,
		&i.Amount,
		&i.RawResponse,
		&i.IsPolling,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getByIdempotencyKey = `-- name: GetByIdempotencyKey :one

SELECT id, user_id, idempotency_key, bill_ref_id, txn_ref_no, payment_method, gateway_rrn, status, amount, raw_response, is_polling, created_at, updated_at FROM giki_wallet.gateway_transactions
WHERE idempotency_key = $1
`

func (q *Queries) GetByIdempotencyKey(ctx context.Context, idempotencyKey uuid.UUID) (GikiWalletGatewayTransaction, error) {
	row := q.db.QueryRow(ctx, getByIdempotencyKey, idempotencyKey)
	var i GikiWalletGatewayTransaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.IdempotencyKey,
		&i.BillRefID,
		&i.TxnRefNo,
		&i.PaymentMethod,
		&i.GatewayRrn,
		&i.Status,
		&i.Amount,
		&i.RawResponse,
		&i.IsPolling,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPendingTransaction = `-- name: GetPendingTransaction :one

SELECT id, user_id, idempotency_key, bill_ref_id, txn_ref_no, payment_method, gateway_rrn, status, amount, raw_response, is_polling, created_at, updated_at FROM giki_wallet.gateway_transactions
WHERE user_id = $1
    AND status IN ('PENDING', 'UNKNOWN')
LIMIT 1
`

func (q *Queries) GetPendingTransaction(ctx context.Context, userID uuid.UUID) (GikiWalletGatewayTransaction, error) {
	row := q.db.QueryRow(ctx, getPendingTransaction, userID)
	var i GikiWalletGatewayTransaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.IdempotencyKey,
		&i.BillRefID,
		&i.TxnRefNo,
		&i.PaymentMethod,
		&i.GatewayRrn,
		&i.Status,
		&i.Amount,
		&i.RawResponse,
		&i.IsPolling,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTransactionByTxnRefNo = `-- name: GetTransactionByTxnRefNo :one

SELECT id, user_id, idempotency_key, bill_ref_id, txn_ref_no, payment_method, gateway_rrn, status, amount, raw_response, is_polling, created_at, updated_at from giki_wallet.gateway_transactions
WHERE txn_ref_no = $1
`

func (q *Queries) GetTransactionByTxnRefNo(ctx context.Context, txnRefNo string) (GikiWalletGatewayTransaction, error) {
	row := q.db.QueryRow(ctx, getTransactionByTxnRefNo, txnRefNo)
	var i GikiWalletGatewayTransaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.IdempotencyKey,
		&i.BillRefID,
		&i.TxnRefNo,
		&i.PaymentMethod,
		&i.GatewayRrn,
		&i.Status,
		&i.Amount,
		&i.RawResponse,
		&i.IsPolling,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUnprocessedAudits = `-- name: GetUnprocessedAudits :many
SELECT id, event_type, raw_payload, txn_ref_no, gateway_ref, user_id, processed, processed_at, process_error, retry_count, received_at FROM giki_wallet.payment_audit_log
WHERE processed = FALSE AND event_type = $1
ORDER BY received_at
LIMIT $2
`

type GetUnprocessedAuditsParams struct {
	EventType GikiWalletAuditEventType `json:"event_type"`
	Limit     int32                    `json:"limit"`
}

func (q *Queries) GetUnprocessedAudits(ctx context.Context, arg GetUnprocessedAuditsParams) ([]GikiWalletPaymentAuditLog, error) {
	rows, err := q.db.Query(ctx, getUnprocessedAudits, arg.EventType, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GikiWalletPaymentAuditLog
	for rows.Next() {
		var i GikiWalletPaymentAuditLog
		if err := rows.Scan(
			&i.ID,
			&i.EventType,
			&i.RawPayload,
			&i.TxnRefNo,
			&i.GatewayRef,
			&i.UserID,
			&i.Processed,
			&i.ProcessedAt,
			&i.ProcessError,
			&i.RetryCount,
			&i.ReceivedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markAuditFailed = `-- name: MarkAuditFailed :exec
UPDATE giki_wallet.payment_audit_log
SET process_error = $2, retry_count = retry_count + 1
WHERE id = $1
`

type MarkAuditFailedParams struct {
	ID           uuid.UUID   `json:"id"`
	ProcessError pgtype.Text `json:"process_error"`
}

func (q *Queries) MarkAuditFailed(ctx context.Context, arg MarkAuditFailedParams) error {
	_, err := q.db.Exec(ctx, markAuditFailed, arg.ID, arg.ProcessError)
	return err
}

const markAuditProcessed = `-- name: MarkAuditProcessed :exec
UPDATE giki_wallet.payment_audit_log
SET processed = TRUE, processed_at = NOW()
WHERE id = $1
`

func (q *Queries) MarkAuditProcessed(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, markAuditProcessed, id)
	return err
}

const updateGatewayTransactionStatus = `-- name: UpdateGatewayTransactionStatus :exec
UPDATE giki_wallet.gateway_transactions SET status = $1 WHERE txn_ref_no = $2
`

type UpdateGatewayTransactionStatusParams struct {
	Status   CurrentStatus `json:"status"`
	TxnRefNo string        `json:"txn_ref_no"`
}

func (q *Queries) UpdateGatewayTransactionStatus(ctx context.Context, arg UpdateGatewayTransactionStatusParams) error {
	_, err := q.db.Exec(ctx, updateGatewayTransactionStatus, arg.Status, arg.TxnRefNo)
	return err
}

const updatePollingStatus = `-- name: UpdatePollingStatus :one

UPDATE giki_wallet.gateway_transactions
SET is_polling = TRUE
WHERE txn_ref_no = $1 AND is_polling = FALSE
RETURNING id, user_id, idempotency_key, bill_ref_id, txn_ref_no, payment_method, gateway_rrn, status, amount, raw_response, is_polling, created_at, updated_at
`

// - update polling status
func (q *Queries) UpdatePollingStatus(ctx context.Context, txnRefNo string) (GikiWalletGatewayTransaction, error) {
	row := q.db.QueryRow(ctx, updatePollingStatus, txnRefNo)
	var i GikiWalletGatewayTransaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.IdempotencyKey,
		&i.BillRefID,
		&i.TxnRefNo,
		&i.PaymentMethod,
		&i.GatewayRrn,
		&i.Status,
		&i.Amount,
		&i.RawResponse,
		&i.IsPolling,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
